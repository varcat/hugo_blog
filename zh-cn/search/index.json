[{"content":"前言 作为一名程序员，我家里折腾了一台性能强劲的 NAS，但受限于内网环境，出门就成了“断线鱼”。虽然手里有一台云服务器，但那点可怜的 CPU 和内存资源，跑个大型服务实在吃力。\n最好的方案莫过于：云服务器只做“路牌”，把流量转发到家里的“性能猛兽”上。\n在对比了多种工具后，我最终选择了 frp。它轻量、稳定且配置极简，完美解决了我的内网穿透需求。今天就把这套“云端中转 + 本地高配”的搭建方案分享给大家。\n为什么选择 frp？ 方案 优点 缺点 适用人群 DDNS (域名解析) 原生速度快，无中转延迟 必须有公网 IP，受限于运营商 有公网 IP 的技术大牛 商业工具 (如花生壳) 傻瓜式操作，无需服务器 免费版带宽极低、限制流量、不安全 零基础小白 VPN (如 Tailscale) 安全性极高，无需中转机 需安装客户端，难实现公网直接访问 纯私人远程办公 frp (自主搭建) 支持全协议、高度自定义、稳定高效 需准备一台公网 VPS 追求极致体验的玩家 frp 工作原理简析 角色分配： frps (Server)： 部署在公网服务器，负责监听和转发。 frpc (Client)： 部署在内网机器，负责发起连接。 流量走向： 用户请求 -\u0026gt; 公网服务器 (frps) -\u0026gt; 隧道 -\u0026gt; 内网设备 (frpc) -\u0026gt; 本地服务。 准备工作 硬件： 一台带公网 IP 的 VPS（云服务器）。 软件： frp GitHub Release 下载对应架构的包。 环境： 确认服务器防火墙已放行对应端口（如 7000, 80/443 等）。 实战配置步骤 服务端配置 (frps.toml) 设置绑定端口。\n安全加固： 设置 auth.token（防止别人蹭你的服务器）。\n1 2 3 4 5 6 7 8 9 bindPort = 7000 # 默认端口 auth.token = \u0026#34;your-secure-token\u0026#34; # 自定义token，建议设置为复杂字符串 transport.tcpMuxKeepaliveInterval = 60 # tcp mux 的心跳检查间隔时间，单位秒 # 端口限制（可选，提升安全性） allowPorts = [ { start = 10000, end = 100010 }, # 允许 10000-100010 端口 { single = 3306 }, # 允许 3306 端口 ] 客户端配置 (frpc.toml) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 基本配置 serverAddr = \u0026#34;\u0026#34; # 公网服务器 IP 或域名 serverPort = 7000 # 公网服务器端口，需与 bindPort 一致 auth.token = \u0026#34;your-secure-token\u0026#34; # 与服务端配置一致 # 基础传输优化 transport.tcpMux = true transport.tcpMuxKeepaliveInterval = 60 # tcp mux 的心跳检查间隔时间，单位秒 # tcp 传输 [[proxies]] name = \u0026#34;ssh\u0026#34; type = \u0026#34;tcp\u0026#34; localPort = 22 remotePort = 8001 # ssh -p 8001 user@serverAddr 常见问题排查 (FAQ) 连接超时 (Timeout) 现象：客户端启动时提示 login to server failed: dial tcp x.x.x.x:7000: i/o timeout。 原因：\n服务器防火墙未放行 bindPort (默认 7000)。 云服务商的安全组未开放对应端口。 服务器 IP 地址填写错误。 解决： 检查服务器防火墙设置 (如 ufw, iptables)。 登录云服务商控制台，检查安全组规则，确保 TCP 7000 端口已放行。 确认客户端配置中的 serverAddr 是否正确。 认证失败 (Authorization Failed) 现象：提示 login to server failed: authorization failed。 原因：\n客户端和服务端的 auth.token 不一致。 时间不同步 (frp 对客户端和服务端的时间差有要求，默认允许偏差 15 分钟)。 解决： 确保 frps.toml 和 frpc.toml 中的 auth.token 完全一致。 检查服务器和客户端的系统时间，必要时进行时间同步 (NTP)。 连接被拒绝 (Connection Refused) 现象：提示 dial tcp x.x.x.x:7000: connect: connection refused。 原因：\n服务端 (frps) 未启动或已停止运行。 服务端监听端口不是 7000。 解决： 在服务器上执行 ps aux | grep frps 检查进程是否存在。 检查服务端配置文件 frps.toml 中的 bindPort 设置，确保与客户端一致。 端口已被占用 (Port Already In Use) 现象：启动时提示 port already in use。 原因：\n指定的端口 (如 7000 或远程映射端口) 已经被其他程序占用。 frp 进程重复启动。 解决： 使用 netstat -tunlp | grep \u0026lt;端口号\u0026gt; 查找占用端口的进程。 修改配置文件中的端口号，或结束占用端口的进程。 结语 通过以上配置，我们成功打通了公网与内网的阻隔，无论是远程管理 NAS、访问内部 Web 服务，还是调试本地代码，frp 都能提供稳定高效的支持。\n相比于其他方案，frp 虽然有一定的配置门槛，但其带来的灵活性和高性能体验是无可比拟的。希望这篇文章能帮你快速上手，搭建属于自己的内网穿透服务，尽情释放本地设备的强大潜能！\n","date":"2026-01-12T22:00:00+08:00","permalink":"https://varcat.github.io/hugo_blog/zh-cn/p/frp/","title":"frp 内网穿透"},{"content":"前言 我手头这台阿里云 ECS 实例平时主要用于托管博客和运行 Docker 服务，此前并未在安全配置上投入太多精力。\n直到最近偶然查看系统日志时，才发现 /var/log/secure 中充斥着密密麻麻的 Failed password for root 记录。经溯源分析，这些恶意登录尝试来自全球各地。面对这数万条暴破记录，我不禁对服务器的处境感到担忧——暴露在公网环境下的服务器，实际上正时刻经受着各类自动化脚本的无差别扫描与攻击。\n尽管我设置了高强度的复杂密码，但这种被持续盯上的潜在风险始终令人不安。一旦防御被突破，服务器上的数据安全将无从谈起。\n因此，我特意抽出时间对服务器进行了全面的安全加固。本文将详细记录这一整改过程，希望能为同样运行着公网服务器的朋友们提供一份实用的安全参考。\n第一步：知己知彼，日志排查 在动手之前，先看看情况到底有多严峻。\n查查有没有人已经混进来了 这是最关键的，先确认“处境”。使用 last 命令查看最近成功的登录记录：\n1 2 # 提取所有登录 IP，过滤掉本地登录和无效干扰 last -i | awk \u0026#39;{print $3}\u0026#39; | grep -E \u0026#34;([0-9]{1,3}\\.){3}[0-9]{1,3}\u0026#34; | sort | uniq -c | sort -nr 重点看有没有陌生的 IP 地址。如果是自己不认识的 IP，那说明已经被攻破了，这时候重装系统可能是最稳妥的选择。好在我查了一圈，除了我自己的 IP，没有别的成功记录。\n看看是谁在敲门 看看那些失败的尝试都来自哪里。可以使用以下命令统计一下攻击者的 IP：\n1 2 3 4 5 6 7 8 9 # 统计所有失败 IP (按次数排序) entOS/RHEL 系通常在 /var/log/secure grep \u0026#34;Failed password\u0026#34; /var/log/auth.log | awk \u0026#39;{print $(NF-3)}\u0026#39; | sort | uniq -c | sort -nr # 统计“不存在的用户”登录尝试 grep \u0026#34;Invalid user\u0026#34; /var/log/auth.log | awk \u0026#39;{print $10}\u0026#39; | sort | uniq -c | sort -nr # Debian 12 及以后 统计密码错误登录失败的 IP journalctl _SYSTEMD_UNIT=ssh.service | grep \u0026#34;Failed password\u0026#34; | awk \u0026#39;{print $(NF-3)}\u0026#39; | sort | uniq -c | sort -nr # 统计不存在用户登录尝试的 IP journalctl _SYSTEMD_UNIT=ssh.service | grep \u0026#34;Invalid user\u0026#34; | awk \u0026#39;{print $10}\u0026#39; | sort | uniq -c | sort -nr 跑完命令，看着那些成百上千的数字，你会有动力的。\n第二步：基础加固，把门焊死 既然是 SSH 暴力破解，那我们就在 SSH 上做文章。\n禁用 Root 直接登录，创建普通用户 直接用 root 登录是大忌。我们先创建一个普通用户，并赋予 sudo 权限。\n1 2 3 4 5 6 7 8 9 # 创建用户 user (换成你自己的名字) useradd -m user passwd user # 赋予 sudo 权限 # CentOS/RHEL: usermod -aG wheel user # Ubuntu/Debian: usermod -aG sudo user 配置 SSH Key 登录，禁用密码 密码再复杂也有被撞破的可能，密钥就安全多了。\n在你的本地电脑（不是服务器）上生成密钥对（如果你还没有的话）：\n1 ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; 然后把公钥传到服务器上：\n方法一：使用 ssh-copy-id（最推荐，最省心） 这是最标准的工具，它会自动处理目录创建、权限设置和内容追加。 1 ssh-copy-id -i ~/.ssh/id_ed25519.pub user@\u0026lt;服务器IP\u0026gt; 方法二：一行命令手动写入 如果你无法直接使用 ssh-copy-id，可以用管道符远程写入： 1 cat ~/.ssh/id_rsa.pub | ssh user@your_vps_ip \u0026#34;mkdir -p ~/.ssh \u0026amp;\u0026amp; cat \u0026gt;\u0026gt; ~/.ssh/authorized_keys\u0026#34; 修改 SSH 配置文件 编辑 /etc/ssh/sshd_config，做以下几个关键修改：\n1 sudo vim /etc/ssh/sshd_config 找到并修改（或添加）以下配置：\n1 2 3 4 5 6 7 8 9 10 11 12 # 1. 修改默认端口，避开 99% 的脚本扫描 # 选一个 1024-65535 之间的端口，比如 22222 Port 22222 # 2. 禁止 root 登录 PermitRootLogin no # 3. 禁止密码登录（必须确保密钥登录已配置好！） PasswordAuthentication no # 4. 仅允许特定用户登录（可选，更严格） AllowUsers user 改完后，别急着重启 sshd，先去阿里云控制台的安全组里，把 TCP 22222 端口放行！否则一重启你就把自己关门外了。\n放行端口后，重启 SSH 服务：\n1 sudo systemctl restart sshd 注意: 先别关当前的ssh窗口，新开一个ssh测试一下能不能用密钥登录成功。\n这时候，绝大多数的扫描脚本因为连不上 22 端口，就已经放弃你的服务器了。\n第三步：主动防御，Fail2Ban 修改端口只能防住傻瓜脚本，对于定向扫描还是不够。这时候就需要 Fail2Ban 登场了。它的原理很简单：检测日志，发现某个 IP 在短时间内多次登录失败，就调用防火墙把它封禁一段时间。\n安装 Fail2Ban 1 2 3 4 5 6 # CentOS/RHEL (需要先安装 EPEL 源) sudo yum install epel-release -y sudo yum install fail2ban -y # Ubuntu/Debian sudo apt-get install fail2ban -y 配置 Jail Fail2Ban 的默认配置文件在 /etc/fail2ban/jail.conf，但我们不要直接改它，而是创建一个 jail.local：\n1 2 sudo cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local sudo vim /etc/fail2ban/jail.local 重点修改 [sshd] 部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 [sshd] enabled = true # 如果你改了端口，这里一定要改 port = 22222 # 过滤规则 filter = sshd # 日志路径 logpath = /var/log/secure # 最大尝试次数 maxretry = 3 # 封禁时间（秒），这里设为一天 bantime = 86400 # 检测时间窗口（秒） findtime = 600 启动并查看状态 1 2 sudo systemctl enable fail2ban sudo systemctl start fail2ban 过一段时间，你可以用这个命令看看战果：\n1 sudo fail2ban-client status sshd 你会看到 \u0026ldquo;Currently banned\u0026rdquo; 后面跟着一串 IP，看着它们被关进小黑屋，心里莫名暗爽。\n第四步：最后的防线，防火墙 虽然阿里云有安全组（Security Group），但我建议系统内部的防火墙（Firewalld 或 UFW）也要开起来，双重保障。\n以 CentOS 的 Firewalld 为例：\n1 2 3 4 5 6 7 8 9 10 11 12 # 启动防火墙 sudo systemctl start firewalld sudo systemctl enable firewalld # 放行新的 SSH 端口 sudo firewall-cmd --permanent --add-port=22222/tcp # 移除默认的 ssh 服务（因为它对应 22 端口） sudo firewall-cmd --permanent --remove-service=ssh # 重载配置 sudo firewall-cmd --reload 总结 经过这一番折腾：\nSSH 端口改了，扫描脚本找不到门。 Root 禁了，必须用普通用户提权。 密码登不上了，必须有密钥。 Fail2Ban 守着，谁敢暴力破解直接封 IP。 再次审视系统日志，异常登录尝试已大幅减少，日志环境恢复了应有的清朗。\n网络安全领域不存在绝对的“铜墙铁壁”，防御的核心策略在于不断提升攻击者的成本。对于个人服务器而言，切实落实上述安全加固措施，足以有效抵御绝大多数自动化脚本的恶意扫描与攻击。\n至此，服务器的基础安全防线已构建完成。\n","date":"2025-11-12T19:34:00+08:00","permalink":"https://varcat.github.io/hugo_blog/zh-cn/p/linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA%E6%8C%87%E5%8D%97%E4%BB%8E%E8%A2%AB%E6%89%AB%E6%8F%8F%E5%88%B0%E7%9D%A1%E4%B8%AA%E5%AE%89%E7%A8%B3%E8%A7%89/","title":"Linux 服务器安全加固指南：从被扫描到睡个安稳觉"},{"content":"瀑布流布局是什么 瀑布流布局是一种常见的网页布局方式，视觉上给人一种参差不齐的多栏的效果，常用于图片为主的版块，如下图。\nok~ 现在我来试着做一做 🧐\n代码实现 基本代码 环境 Chrome 81.0.4044.138\nHTML\n1 \u0026lt;main\u0026gt;\u0026lt;/main\u0026gt; CSS\n1 2 3 4 5 6 7 8 9 * { box-sizing: border-box; } main { width: 600px; padding: 5px; box-shadow: 0 0 5px 1px rgba(0, 0, 0, 0.15); } JavaScript\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 用于生成随机颜色 const getRandomColor = () =\u0026gt; `#${Math.random().toString(16).slice(2, 8)}`; // 用于生成随机高度 const genRandomHeight = () =\u0026gt; `${Math.ceil(Math.random() * 100 + 15)}px`; const mainEl = document.querySelector(\u0026#34;main\u0026#34;); // 生成100个div，方便查看效果 mainEl.innerHTML = Array.from({ length: 100 }, (x, i) =\u0026gt; { return ` \u0026lt;div class=\u0026#34;item\u0026#34; style=\u0026#34;background: ${getRandomColor()}; height: ${genRandomHeight()}\u0026#34;\u0026gt; ${i} \u0026lt;/div\u0026gt;`; }).join(\u0026#34;\u0026#34;); 好了，现在我得到了下面的画面，看起来也像瀑布流，参差不齐，除了没有多列 😀\ncolumns 实现 我们还缺少一个多列，很容易想到 css 的多列布局 columns，那么事情就简单起来了。\n在 css 文件，main 元素里加上一句\n1 2 3 4 main { // ... columns: 12; } emmm~ 好像很容易就实现了，不过等等，32、39、58、66、84、92 这几个 div 好像被腰斩了，而且元素的排序是从上往下，而不是人们熟悉的从左到右 🤔\n查看 CSS Multi-column Layout Module Level 1 规范后，多列布局会为子元素的内容生成 anonymous fragmentation containers 匿名盒子，溢出的内容会被分段，换列显示，想要控制分段，可以使用 break-inside: avoid（参考 column-break-values）\ncss 文件中加入这一句\n1 2 // ... break-inside: avoid; 考虑到浏览器对 break-inside 的支持不太好，可以试用\n1 2 3 4 .item { display: inline-block; width: 100%; } 缺点就是会出现白色间隙。\ngrid 实现 通过 columns 实现瀑布流布局，一大缺点是不方便改变子元素的顺序从左往右，这时可以试用 grid 来实现。\n基本代码不变\n1 2 3 4 5 6 7 8 9 main { // ... // width: 600px; 去掉这个固定宽度，这里可以不使用， display: grid; // auto-fill尽可能的填充列，列的最小宽度应为40px，最大1fr，灵活的调整，让每列宽度相同 grid-template-columns: repeat(auto-fill, minmax(40px, 1fr)); grid-auto-rows: 40px; grid-gap: 5px; } 现在我有了一个简单的grid布局，它保持了给定的顺序，并且会自动根据浏览器宽度调整列数。同时，我们也发现了几个问题，因为行高固定，所有有溢出的div，同时有些div高度不到行高，所以会有丑陋的白色间隙，当下grid布局是不会让子元素自动跨越行，所以要人工干预，我需要调整每一个div，让他们跨越不同的行数，比如 grid-row-end: span 2;。\n这里需要使用 js 来动态设置每个 div 所跨越的行数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 获取行高与间距，目前行高是40px，间距是5px const rowHeight = parseInt( getComputedStyle(mainEl).getPropertyValue(\u0026#34;grid-auto-rows\u0026#34;) ); const rowGap = parseInt( getComputedStyle(mainEl).getPropertyValue(\u0026#34;grid-row-gap\u0026#34;) ); const setSpan = el =\u0026gt; { // 计算div需要跨越的行数 el.style.gridRowEnd = `span ${Math.ceil( (el.clientHeight + rowGap) / (rowHeight + rowGap) )}`; }; document.querySelectorAll(\u0026#34;.item\u0026#34;).forEach(setSpan); 很好，我们计算出了div能完全显示的最小行数，但还有有很多间隙，因为我们的行高设置的40px，计算不精确，所以最终的解决方案是将行高设置为较小的数。\n1 2 3 4 5 main { // ... // 原来是40px，现在改为1px grid-auto-rows: 1px; } 🎉🎉看起来不错～\n","date":"2020-05-17T23:45:00+08:00","permalink":"https://varcat.github.io/hugo_blog/zh-cn/p/css-waterfall-flow/","title":"CSS瀑布流布局"}]